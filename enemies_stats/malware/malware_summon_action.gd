extends EnemyAction

@export var worm_scene: PackedScene       # The Worm enemy scene to instantiate
@export var summoned_ai: PackedScene     # The AI PackedScene to use for the summoned worm
var already_summoned := false

func is_performable() -> bool:
	if not enemy or already_summoned:
		return false

	# Use float arithmetic to avoid integer-division warnings
	var hp_threshold := float(enemy.stats.max_health) / 2.0
	return enemy.stats.health <= hp_threshold

func perform_action() -> void:
	if not enemy or not worm_scene:
		return

	already_summoned = true

	# Find EnemyHandler (make sure your EnemyHandler node is in the "enemy_handler" group)
	var enemy_handler := get_tree().get_first_node_in_group("enemy_handler")
	if not enemy_handler:
		push_warning("WormSummonAction: No EnemyHandler found in scene tree (group 'enemy_handler').")
		return

	# Instantiate the worm scene
	var new_enemy: Enemy = worm_scene.instantiate()

	# Duplicate stats resource (so we don't share the same resource instance)
	var new_stats = enemy.stats.duplicate()
	# Override AI so summoned worm uses a different AI than the summoner
	if summoned_ai:
		# new_stats is expected to be of type EnemyStats (it has `ai` exported)
		new_stats.ai = summoned_ai
	else:
		# If you leave summoned_ai empty, you can decide whether to keep the original AI:
		# new_stats.ai = new_stats.ai  # keeps the original AI (no-op)
		# OR set to null if you want no AI assigned by default:
		# new_stats.ai = null
		pass

	# Give the summoned worm the current HP of the summoner
	new_stats.health = enemy.stats.health

	# Set enemy stats BEFORE fully adding to the scene so initialization runs properly.
	# update_enemy() will await `ready` if the node is not in tree yet (safe).
	new_enemy.set_enemy_stats(new_stats)

	# Position the new worm beside the summoner so they don't overlap
	new_enemy.position = enemy.position + Vector2(64, 0)

	# Add to EnemyHandler so it is part of the battle
	enemy_handler.add_child(new_enemy)

	# Connect statuses_applied to the EnemyHandler like setup_enemies() does
	# (this mirrors your existing setup_enemies behavior)
	new_enemy.status_handler.statuses_applied.connect(enemy_handler._on_enemy_statuses_applied.bind(new_enemy))

	# Complete the action after a short delay (allow for animation/sound if desired)
	get_tree().create_timer(0.6).timeout.connect(
		func():
			Events.enemy_action_completed.emit(enemy)
	)
